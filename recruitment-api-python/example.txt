When it comes to analyzing PDF files with GPT-4o API, users often face several questions and challenges.

In the Web GUI (chatgpt.com), users simply drag-and-drop the PDF and ask the question in the prompt, but with API you are required to make a few extra steps:

    Create (or fetch) Assistant object. The Assistant object has to have File Search under tools enabled. Note that you can’t enable the JSON mode, as it’s not available for “file_search” (JSON mode is only available for “function” tools).
    Upload file(s) — a pdf, or other supported format. You’ll need to save the ID of the file, so you can pass it when creating a Thread later. Note that the .pdf will be processed as a text document, not an image (so the cost will be low).
    Create a Thread, add a “user” message to it (with file attachment and prompt data), and assign the Assistant to it.
    Run the Thread. We’ll run it in Polling mode (not streaming mode), so the function will return only after the Run lifecycle is finished (either completed, failed, was cancelled, or expired).

Press enter or click to view image in full size

5. If you want to get JSON output, you’ll need to parse the GPT-4o response manually. The model will answer with something similar to the text below, so you’d use regex (or similar) to extract the valid JSON output.

Of course, here's the total purchase order amount:
```json
{
  "price": 1234.56
}
```

6. (Optionally) Delete the file(s) you have uploaded. OpenAI API docs mention that each file can be up to 512MB in size, and that all files together (in an organization) have to be below 100GB.
The code

Here’s the Python code that achieves this, using version 1.33.0 openai library (where assistants are still in Beta):

from openai import OpenAI # Version 1.33.0
from openai.types.beta.threads.message_create_params import Attachment, AttachmentToolFileSearch
import json

MY_OPENAI_KEY = 'sk-...' # Add your OpenAI API key
client = OpenAI(api_key=MY_OPENAI_KEY)

# Upload your pdf(s) to the OpenAI API
file = client.files.create(
    file=open('my_file.pdf', 'rb'),
    purpose='assistants'
)

# Create thread
thread = client.beta.threads.create()

# Create an Assistant (or fetch it if it was already created). It has to have
# "file_search" tool enabled to attach files when prompting it.
def get_assistant():
    for assistant in client.beta.assistants.list():
        if assistant.name == 'My Assistant Name':
            return assistant

    # No Assistant found, create a new one
    return client.beta.assistants.create(
        model='gpt-4o',
        description='You are a PDF retrieval assistant.',
        instructions="You are a helpful assistant designed to output only JSON. Find information from the text and files provided.",
        tools=[{"type": "file_search"}],
        # response_format={"type": "json_object"}, # Isn't possible with "file_search"
        name='My Assistant Name',
    )

# Add your prompt here
prompt = "What's the total price of the purchase order in PDF? Output in JSON format, like:\n{'price': 123.45}"
client.beta.threads.messages.create(
    thread_id = thread.id,
    role='user',
    content=prompt,
    attachments=[Attachment(file_id=file.id, tools=[AttachmentToolFileSearch(type='file_search')])]
)

# Run the created thread with the assistant. It will wait until the message is processed.
run = client.beta.threads.runs.create_and_poll(
    thread_id=thread.id,
    assistant_id=get_assistant().id,
    timeout=300, # 5 minutes
    # response_format={"type": "json_object"}, # Isn't possible
)

# Eg. issue with openai server
if run.status != "completed":
    raise Exception('Run failed:', run.status)

# Fetch outputs of the thread
messages_cursor = client.beta.threads.messages.list(thread_id=thread.id)
messages = [message for message in messages_cursor]

message = messages[0] # This is the output from the Assistant (second message is your message)
assert message.content[0].type == "text"

# Output text of the Assistant
res_txt = message.content[0].text.value

# Because the Assistant can't produce JSON (as we're using "file_search"),
# it will likely output text + some JSON code. We can parse and extract just
# the JSON part, and ignore everything else (eg. gpt4o will start with something
# similar to "Of course, here's the parsed text: {useful_JSON_here}")
if res_txt.startswith('```json'):
    res_txt = res_txt[6:]
if res_txt.endswith('```'):
    res_txt = res_txt[:-3]
res_txt = res_txt[:res_txt.rfind('}')+1]
res_txt = res_txt[res_txt.find('{'):]
res_txt.strip()

# Parse the JSON output
data = json.loads(res_txt)

print(data)

# Delete the file(s) afterward to preserve space (max 100gb/company)
delete_ok = client.files.delete(file.id)